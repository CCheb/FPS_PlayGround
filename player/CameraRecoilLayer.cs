using Godot;
using System;

public partial class CameraRecoilLayer : CameraLayer
{
    // Custom signal that will add Camera recoil
	[Signal] public delegate void AddCameraRecoilSignalEventHandler();

	// How much the camera should "kick". Give it a greater +X and it will rotate up
	[Export] public Vector3 recoilAmount = Vector3.Zero;
	// How much does the camera follow the recoil kick generated by targetRotation
	// The larger the snapAmount the sharper the camera rotation is since its tightly follows targetRotation
	[Export] public float snapAmount = 0.0f;
	// How fast does the recoil decay back to 0.0
	// The higher the speed the faster the player is able to recover from the recoil kick
	[Export] public float speed = 0.0f;

	// currentRotation follows targetRotation. Current camera rotation which follows targetRotation. Actual rotation
	private Vector3 currentRotation = Vector3.Zero;
	// Everytime we fire the gun we want to alter the cameras rotation with this vector. Ideal Rotation
	private Vector3 targetRotation = Vector3.Zero;

    // currentRotation is considered the final output of this layer. We only need to calculate and pass this data
    // over to the CameraController. RotationOffset simply gets the currentRotation value
    public override Vector3 RotationOffset => currentRotation;
	// Called when the node enters the scene tree for the first time.
	public override void _Ready()
	{
		// Everytime AddCameraRecoilSignal is emmited the AddRecoil Function will be emitted
		// An object of Recoil is able to emmit this signal and whatever function is connected
		// to the signal will be called. In this case the signal will be emitted in the WeaponControllers shoot function
		AddCameraRecoilSignal += AddRecoil;
    }

	// Called every frame. 'delta' is the elapsed time since the previous frame.
	public override void _Process(double delta)
	{
		// Everytime we add recoil it will be constantly lerp back to zero and the results
		// passed on to currentRotation which follows targetRotation
		targetRotation = targetRotation.Lerp(Vector3.Zero, speed * (float)delta);
		currentRotation = currentRotation.Lerp(targetRotation, snapAmount * (float)delta);
	}
	
	// Call this function everytime we shoot to add recoil to the camera
	private void AddRecoil()
	{
		// We can think of each of these values as angles that we 
		// Z and Y generate a random kick of recoil which introduces nice patterns
		// X has no randomness since we want the world camera to kick vertically up only
		// Vertical recoil is held back by targetRotation which is always trying to go back to level
		// thats what you see when you keep shooting and the recoil seems to level off
		targetRotation += new Vector3(recoilAmount.X,
			(float)GD.RandRange(-recoilAmount.Y, recoilAmount.Y), (float)GD.RandRange(-recoilAmount.Z, recoilAmount.Z));
    }	
}
